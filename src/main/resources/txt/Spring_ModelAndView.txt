=================================================================================
SPRING MODELANDVIEW
=================================================================================
1. GENERALLY
2. CONTROLLER AND SERVICE IN MODEL&VIEW
3. CONSTRUCTORS
4. METHODS
5. TESTING

=>WEB APPLICATION
=>MAP
=>SPRING THYMELEAF
=>SPRING BOOT REQUESTS
=>SPRING BOOT CONTROLLER
=>SPRING BOOT TESTS
=>SPRING BOOT CONTROLLER TESTS
=>SPRING EXCEPTION HANDLING
=>SPRING BOOT VALIDATION

=================================================================================
1. GENERALLY
=================================================================================
The Communication layer as a whole, or endpoints of the layer can work in two different modes:
    a. model&view mode
    b. object mode

The model&view mode covers working with models and templates. That said, the sent payload is rendered into a Model object, and the payload is sent to a template.
The return value of the controller method must be a String which contains the name of the view, Spring attaches the Model to it.
The Model object can contain several objects.
An endpoint, and through the endpoints the controller can not comply to the REST standard.

=================================================================================
2. CONTROLLER AND SERVICE IN MODEL&VIEW
=================================================================================
In order to form an API, thin controller is needed. That said, the controller is separated from the Business layer. Thin controller means thin endpoints along.
The controller method receives a new (empty) Model object in its argument list.

EXAMPLE FOR THIN CONTROLLER ENDPOINT (MODEL&VIEW):
@GetMapping("/endpoint") //or other request type(s)
public String controllerMethodName([received request parameters marked with @ModelAttribute, ]Model model) {
	ModelAndView modelAndView = serviceObject.serviceMethodName("initial_view_name"[, sent request parameters]);
	model.addAllAttributes(modelAndView.getModel());
	return modelAndView.getViewName();
}
END OF EXAMPLE

The Model part of ModelAndView object contains objects, organized into a Map<String, Object> type where the keys are HTML attribute names, the values are the corresponding objects of any class. In order to access a value, casting will be necessary in the Business layer.
On Business layer side, the correspondent service method will be invoked which returns a ModelAndView object filled with elements of the payload and the name of the view.

EXAMPLE FOR SERVICE METHOD (MODEL&VIEW):
public ModelAndView serviceMethodName(String initialView[, received request parameters]) {
    //process
    ModelAndView modelAndView = new ModelAndView(initialView); //if needed
    modelAndView.addObject("html_attribute_name1", object_variable_or_object_or_literal1);
    modelAndView.addObject("html_attribute_name2", object_variable_or_object_or_literal2);
	modelAndView.setViewName("final_view_name"); //optionally, if needed
    return modelAndView;
	}
}
END OF EXAMPLE

=================================================================================
3. CONSTRUCTORS
=================================================================================
The constructor parameters of ModelAndView can have the next main variants:
    a. String viewName
    b. View view
    c. String viewName, Map<String, ?> model
    d. View view, Map<String, ?> model
    e. String viewName, HttpStatusCode status
    f. String viewName, Map<String, ?> model, HttpStatusCode status
    g. (no arguments)

It is possible to create a ModelAndView object without defining the view name (or the View). This can be done only by giving no arguments to the constructor.

=================================================================================
4. METHODS
=================================================================================
The ModelAndView has the next methods.

||ModelAndView method|Description||
||addObject("Html_attribute_name", object)|adds an object to the payload with its HTTP attribute name||
||addObject(object)|adds an object to the payload, HTTP attribute name is automatically set||
||addAllObjects(Map<String, ?>)|adds the content of the Map to the payload, HTTP attribute names are the keys||
||setViewName("view_name")|sets the view||
||setView(View view)|sets the view||
||setStatus(HttpStatusCode status)|sets the response status||
||clear()|deletes all data||
||isEmpty()|checks whether no data in it||
||wasCleared()|checks whether it was cleared||
||hasView()|checks whether it has view||
||getViewName()|returns the name of the view||
||getView()|returns the View||
||getModel()|returns the model as Map<String, Object>||
||getStatus()|returns the HttpStatusCode||
||getModelMap()|returns a ModelMap||

The returned View object has one method:
    getContentType(): returns the content-type as String

The returned ModelMap has methods with which the attribute names and objects can be managed.
This class is inherited from the Map interface, additional methods are below.

||ModelMap method|Description||
||addAttribute("Html_attribute_name", object)|adds an object to the payload with its HTTP attribute name||
||addAttribute(object)|adds an object to the payload, HTTP attribute name is automatically set||
||addAllAttributes(Map<String, ?>)|adds the content of the Map to the payload, HTTP attribute names are the keys||
||addAllAttributes(Collection<?>)|adds the content of the Collection to the payload, HTTP attribute names is automatically set||
||containsAttribute("attribute_name")|checks whether the attribute is contained||
||getAttribute("attribute_name")|returns the object by the attribute name (needs type casting afterwards)||
||mergeAttributes(Map<String, ?>)|-||

The return value of add...() and merge...() methods is ModelMap therefore it is possible to chain these methods.

EXAMPLE FOR CHAINING MODELMAP METHODS:
public ModelAndView serviceMethod(String initialView) {
    ModelAndView modelAndView = new ModelAndView(initialView);
    modelAndView.getModelMap()
            .addAttribute("attribute_name1", object1)
            .addAttribute("attribute_name2", object2)
            .addAttribute("attribute_name3", object3);
}
END OF EXAMPLE

=================================================================================
5. TESTING
=================================================================================
Full test an attribute requires tree steps:
    a. checking existence of the attribute
    b. checking class of the attribute
    c. checking content of the attribute

With JUnit, please note that in tests when stored attributes are checked with Assertions, assertEquals(true|false, ...) is preferred over assertTrue|assertFalse() on Boolean HTML attributes.
Similarly, assertEquals(new ArraysList<>(), ...) is preferred over checking emptiness of a List with assertTrue|assertFalse(...isEmpty()).

EXAMPLE FOR TESTING MODELANDVIEW (JUNIT ASSERTIONS):
ModelAndView modelAndView = ... //invoking tested method

Assertions.assertTrue(modelAndView.hasView());
Assertions.assertEquals("view_name", modelAndView.getViewName());

ModelMap modelMap = modelAndView.getModelMap();
Assertions.assertEquals(numberOfExpectedContainedAttributes, modelMap.size());

//check against expected value (generally)
Assertions.assertTrue(modelMap.containsAttribute("html_attribute_name"));
Assertions.assertTrue(modelMap.getAttribute("html_attribute_name") instanceof ClassName);
Assertions.assertEquals(expectedValue, modelMap.getAttribute("html_attribute_name"));

//check Boolean
Assertions.assertTrue(modelMap.containsAttribute("html_attribute_name"));
Assertions.assertTrue(modelMap.getAttribute("html_attribute_name") instanceof Boolean);
Assertions.assertEquals(true, modelMap.getAttribute("html_attribute_name"));

//check String against emptiness
Assertions.assertTrue(modelMap.containsAttribute("html_attribute_name"));
Assertions.assertTrue(modelMap.getAttribute("html_attribute_name") instanceof String);
Assertions.assertEquals("", modelMap.getAttribute("html_attribute_name"));

//check List against emptiness
Assertions.assertTrue(modelMap.containsAttribute("html_array_attribute_name"));
Assertions.assertTrue(modelMap.getAttribute("html_array_attribute_name") instanceof List);
Assertions.assertEquals(new ArrayList<>(), modelMap.getAttribute("html_array_attribute_name"));
END OF EXAMPLE

EXAMPLE FOR TESTING MODELANDVIEW (MODELANDVIEWASSERT):
ModelAndView expectedModelAndView = new ModelAndView("view_name");
expectedModelAndView.getModelMap().addAttribute("html_attribute_name", attribute_value);
//mock service method if needed, returns expectedModelAndView

ModelAndView modelAndView = ... //invoke tested method
ModelAndViewAssert.assertViewName(modelAndView, "view_name");

ModelAndViewAssert.assertModelAttributeValues(modelAndView, expectedModelAndView.getModel()); //or:

ModelAndViewAssert.assertModelAttributeAvailable(modelAndView, "html_attribute_name");
ModelAndViewAssert.assertAndReturnModelAttributeOfType(modelAndView, "html_attribute_name", Element.class);
ModelAndViewAssert.assertModelAttributeValue(modelAndView, "html_attribute_name", attribute_value);
END OF EXAMPLE
