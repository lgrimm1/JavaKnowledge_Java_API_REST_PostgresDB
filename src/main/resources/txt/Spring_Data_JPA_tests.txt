=================================================================================
SPRING DATA JPA TESTS
=================================================================================
In case of using Spring Data JPA, instead of class the repository will be an interface, by default no tests for functionality are needed since the functionalities will be given by the Spring itself.
Usually, next to the default (inherited) methods, overridden, derived and custom query methods are defined. Functionality of these methods are dependent on using of correct keywords, SQL (JPQL) commands and code blocks. In such cases, repository tests are necessary.

A JPA repository test class uses class-level annotations.

||Annotation|Description||
||@DataJpaTest|instructs Spring to create a test slice for JPA||
||@Transactional(propagation = Propagation.NOT_SUPPORTED)|disables transaction management||
||@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)|configuration of the database||
||@AutoConfigureTestEntityManager|configuration of TestEntityManager outside DataJpaTest class||

When using @DataJpaTest annotation, Spring will load context for JPA and below (entity level) but not above.
By default, after every test Spring rolls back the database (transaction management for tests). This behaviour can be controlled with @Transactional annotation.
Except for H2, the database needs configuration, use @AutoConfigureTestDatabase for this purpose.

The TestEntityManager is the test version of the EntityManager, optionally can be used for testing if the test strategy needs it. When using, first it must be injected with @Autowired.
In case it is necessary to use TestEntityManager outside of @DataJpaTest instances, add class-level @AutoConfigureTestEntityManager annotation to that class.

In case if using JUnit4, the class-level @RunWith(SpringRunner.class) annotation is needed additionally.

The database at the beginning is practically empty, the configuration class optionally presented for repositories or above will not be injected by JPA.
In case the tests are not invoked in chain starting with filling with data, along with disabling transactional management, need to fill the database per test method or with a @BeforeEach method before.

EXAMPLE FOR JPA TEST CLASS:
package Package;

import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.boot.test.autoconfigure.jdbc.*;
import org.springframework.boot.test.autoconfigure.orm.jpa.*;

import java.util.*;

@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class TitleRepositoryTest {

	@Autowired
	private TestEntityManager testEntityManager;

	@Autowired
	Repository repository;

	@BeforeEach
	void setUp() {
        //set up database records for every tests
	}

	@Test
   	void testEntityManagerExample() throws Exception {
    	this.testEntityManager.persist(new Entity(...));
        //assertions etc.
   	}

	@Test
	void testCase() {
	    //prepare database if not prepared in @BeforeEach
	    //invoke method
	    //assertions
	}
}
END OF EXAMPLE

=>SPRING BOOT REPOSITORY
=>SPRING BOOT TESTS
