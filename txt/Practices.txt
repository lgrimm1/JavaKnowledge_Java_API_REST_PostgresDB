=================================================================================
PRACTICES
=================================================================================
1. GIT COMMANDS
2. RUNTIME COMPLEXITY
3. CLEARER CODE VIA LAMBDAS
4. USING RIGHT RETURN VALUES FOR BETTER INTEGRATION
5. GET APPLICATION PATHS
6. FAVORING COMPOSITION OVER INHERITANCE
7. PRINCIPLES OF SOFTWARE ENGINEERING
8. QUALITY SOURCES OF JAVA, FRAMEWORKS AND FRONTEND
9. INCREASE ARRAY INDEX, JUMP TO FIRST ELEMENT WHEN REACHING LAST
10. INCREASE ARRAY CAPACITY
11. INDEXOF WITH STREAM
12. RECURSIVE SORTING
13. LINKED LIST
14. DOUBLE LINKED LIST
15. QUEUE WITH ARRAY
16. ROUND ROBIN QUEUE (WITH ARRAYLIST OF STRING ITERATORS)
17. ROUND ROBIN QUEUE (WITH QUEUE OF STRING ITERATORS)
18. PALINDROME (STRING EQUALS ITS REVERSED FORM)
19. CLEAN ALL WHITE SPACES AND NON-VISIBLE CHARACTERS

=================================================================================
1. GIT COMMANDS
=================================================================================
Repository: a project on the remote git server (e.g. Github, GitBucket).
Master: the remote summarized code (alive code) on the git server.
HEAD: the local summarized code.
Snapshot: a committed local version.
Branch: all actions are rendered into branches, dividing from the original; a developer works on a branch.

For codes, the code exists in remote repository, in local repository (e.g. under .git folder) and in local code.
If these are identical, the project is synchronized.

||COMMAND|ACTION||
||git log|shows history of the live branch for commits etc.; for commits shows hash codes as well||
||git checkout branch_name|makes the given branch alive||
||git checkout -b branch_name|creates a new one and makes that branch the live branch||
||git checkout hashcode|reverts to the given snapshot of the live branch; jumps back to the last one for git checkout branch_name||
||git status|shows infos about the active branch (tracked and untracked files)||
||git add file_name|marks the file as staged (means marking them for committing)||
||git add .|marks all files (.) as staged (means marking them for committing)||
||git restore --staged file_name|un-stages the given file, will not be committed||
||git commit|creates a snapshot on the alive branch||
||git commit -m "message"|creates a snapshot on the alive branch, renders the message to that snapshot||
||git push|sends the committed code of actual branch up to server; in case there is not the local active branch on the server yet, suggests a command instead of this||
||git pull|downloads the snapshots of the live branch which are not found at local from the server, therefore updates the local repository and code with the remote one (synchronizes), identical with fetch + merge||
||git fetch|downloads the snapshots of the live branch which are not found at local from the server, therefore changes will appear in code but it will not update the local repository||
||git merge|updates the local repository with the local code; after fetch the project will be synchronized with the remote repository||
||git clone|clones (creates a copy of) a repository||

* is for marking a character, ** is for marking many. ** can mark whole path to a file as well e.g. **a** can mean path/a*.* files. The dot (.) means all files at actual and all its sub-folders.

In case there are pushed snapshots on the server, these will be under the name of the contributor.
Such snapshots are ideal for having backups of local codes as well.

Fetching is ideal for reviewing codes without merging the checked code with local repository. For this, change the actual branch as needed. When finished, change the actual branch to the one in which you work and use pull for synchronizing.

In order to send a pushed snapshot to the master contributor(s), use the Pull Request function on the server.
A master contributor of the reposition (owner) will review the changes, if satisfied, will merge the branch with the Master code.

Usual message for work-in-progress snapshots (not for Pull Request): WIP.

For those files which should not be included in file tracking, put those into .gitignore.

EXAMPLE FOR ADDING A FILE TO LOCAL AND REMOTE REPOSITORIES:
git init
git add <filename>
git commit -m "commit message"
git remote add origin <link to remote repository>
git push origin <branch name>
END OF EXAMPLE

=================================================================================
2. RUNTIME COMPLEXITY
=================================================================================
Marks how many time a method must run in order to finish a task.
The O letter marks the complexity. The n letter means the amount of input data.
For defining the complexity, use the scale of need.
Runtime is dependent on existence of parallel execution method. However, because JVM directs how the parallel execution is done (e.g. Streams), and there can be cases when JVM can not execute parallel even if we let it doing it, we must assume the maximum runtime without parallel ways.

O(1):
    - constant runtime
    - process which must be executed once only, independent of the amount of data

EXAMPLE FOR O(1):
public void push(int key) {
    if (lastIndex == capacity -1) {
        array = Arrays.copyOf(array, capacity * 2);
        capacity *= 2;
    }
    lastIndex = (++lastIndex) % capacity;
    array[lastIndex] = key;
}
END OF EXAMPLE

O(n):
    - linear runtime
    - the numbers of executions depends on the number of data
    - typically processing collections or arrays by their elements in 1D
    - linear search on unsorted collection or array in 1D

EXAMPLE FOR O(N):
public long total(int[] array) {
    long total = 0; //does not count into complexity because for higher length of arrays, it will not change the scale
    for (int i = 0; i < array.length; i++) {
        array[i] = Math.pow(array[i], 2);
    }
    return total; //does not count into complexity because for higher length of arrays, it will not change the scale
}
END OF EXAMPLE

O(m + n):
    - iterating through 2 different collections or arrays with 2 independent loops

EXAMPLE FOR O(M + N):
int[] ia = ...
List<String> sal = new ArrayList<>(...);
...
for (int i = 0; i < ia.length; i++) {
    ...
}
for (String s : sal) {
    ...
}
END OF EXAMPLE

O(n^2):
    - quadratic runtime
    - when every element must be compared with all other elements in a collection or array in 1D
    - usually goes for minimum needed complexity of sorting processes (using iteration or recursion does not matter)
    - 2 nested loops (e.g. processing all elements of collections or arrays in 2D)
The less optimized sorting linearly steps an index from a base point, then repeats the execution from the next base point. With element of the low index all other elements will be compared. The execution number would be: (n - 1) + (n - 2) + (n - 3) + ... + (n - n-1) = n^2.

EXAMPLE FOR O(N^2):
int[][] ia = new ia[x][y]{...};
...
for (int i = 0; i < x; i++) {
    for (int j = 0; j < y; j++) {
        //process cell
    }
}
END OF EXAMPLE

O(log(n)):
    - logarithmic runtime
    - logarithmic search on sorted collection or array in 1D
    - Merge Sort (mathematically proven that the most optimized sorting algorithm needs log(n) executions)

O(n * log(n)):
    - quasilinear runtime
    - standard sorting algorithms

Java Collection.sort() method:
    - uses Merge Sort for higher amount of data (needs more data to work efficiently)
    - uses simpler algorithms for fewer data
    - this behaviour can change when the element class has unique compareTo() method, or for sorting unique Comparator is used

=================================================================================
3. CLEARER CODE VIA LAMBDAS
=================================================================================
Best practices are:
    - for small function objects, prefer lambdas before anonymous classes
    - for method references, use lambda instead
    - if needed, for functional interfaces use the pre-defined ones in java.util.function.Function
    - when declaring a functional interface, always use the @FunctionalInterface annotation
    - in case a lambda would need many statements in a code block, organize it into an external (helper) method (short and self-explanatory lambda)
    - in lambda, avoid referencing the input variable types, use them only when the compiler asks for it
    - avoid braces when have 1 parameter in lambda
    - using return statement in statement part of lambda is optional, do not use it

EXAMPLE FOR METHOD REFERENCE:
ClassName::methodName
END OF EXAMPLE

EXAMPLE FOR LAMBDA INSTEAD OF METHOD REFERENCE:
() -> methodName()
END OF EXAMPLE

EXAMPLE FOR ORGANIZING BLOCK-BODY LAMBDA:
//instead of this:
(...) -> {
    statement1;
    statement2;
    ...
    statementn;
    }
//use this:
private returnValue methodName(...) {
    statement1;
    statement2;
    ...
    statementn;
}
...
(...) -> methodName(...)
END OF EXAMPLE

EXAMPLE FOR AVOIDING VARIABLE TYPES IN LAMBDA:
//instead of this:
(type1 var1, type2 var2) -> ...
//use this:
(var1, var2) -> ...
END OF EXAMPLE

EXAMPLE FOR USING BRACES WITH LAMBDA:
() -> statement
parameter -> statement
(parameter1, parameter2, ...) -> statement
END OF EXAMPLE

EXAMPLE FOR AVOIDING RETURN STATEMENT IN LAMBDA:
//instead of this:
() -> return methodName()
//use this:
() -> methodName()
END OF EXAMPLE

=================================================================================
4. USING RIGHT RETURN VALUES FOR BETTER INTEGRATION
=================================================================================
When designing a method, the return value represents the purpose of the method.
Narrowing down the type onto the lower level (e.g. ArrayList<Integer>) forces the other developer to accept such type when designing his or her own methods.
It is a good practice to design a return value which can be used in several ways, via several types, so the other developer can have its own options.
In case an implementation would be the down-narrowed type, always use its interface as a type.
In many occasions, the pre-defined conversion methods with which a series of data can be created, will offer interface as type from the beginning.

EXAMPLE FOR USING INTERFACE AS RETURN TYPE (no1):
import java.util.List;
import java.util.stream.Stream;
import java.util.stream.IntStream;
...
public List<Integer> newNumbers() {
    return IntStream.rangeClosed(1, 10).boxed().toList();
}
END OF EXAMPLE

EXAMPLE FOR USING INTERFACE AS RETURN TYPE (no2):
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;
...
private static List<Integer> generateCircledPermutations(int number) {
    List<Integer> permutations = new ArrayList<>();
    //manipulating the list by passed number
    return permutations;
}
//on the caller's side, the caller statement can put the return value into a List, an ArrayList, a LinkedList etc.
END OF EXAMPLE

=================================================================================
5. GET APPLICATION PATHS
=================================================================================
5.1. APPLICATION PATHS
5.2. MAVEN TEST RESOURCES PATHS

5.1. APPLICATION PATHS
---------------------------------------------------------------------------------
The installed application has an application root folder from which all sub-folders is created. The sub-folder structure depends on whether a build system is used for development, and if used, depends on the used build system (Maven, Gradle etc.).

EXAMPLE FOR GETTING APPLICATION ROOT FOLDER:
String projectRoot = "."; //or:
String projectRoot = System.getProperty("user.dir");
Path projectRootPath = Paths.get("."); //or:
Path projectRootPath = Path.get(System.getProperty("user.dir"));
END OF EXAMPLE

The installed application will not contain source folders (e.g. /scr folders under Maven). Different folders will be accessed by default in development and in production cycle.
The application under IntelliJ IDEA (with or without Maven) can use the following folders for keeping the .java source files:
    - /src
    - /src/main
    - /src/main/java
When accessing these folders, use File.separator instead of / character for platform independence.

Because these folders rarely exist under installed application but the original user dir is not accessible in the development cycle, it is a good practice to check all of them against file existence. Once a file is found, that will point out which folder should be used as application root folder.
Also, it is possible to create numerous unique folders directly under the project root. These folders will be available in the development cycle. With application initialization, always check these folders for existence and if needed, create them before usage.

EXAMPLE FOR DECLARING ALL POSSIBLE APPLICATION ROOT FOLDERS:
import java.io.File;
...
public static String[] listSourceFoldersIntelliJMaven() {
	String userDir = System.getProperty("user.dir");
	return new String[]{
			userDir,
			userDir + File.separator + "src",
			userDir + File.separator + "src" + File.separator + "main",
			userDir + File.separator + "src" + File.separator + "main" + File.separator + "java"
	};
}
END OF EXAMPLE

5.2. MAVEN TEST RESOURCES PATHS
---------------------------------------------------------------------------------
For test environment, Maven uses the src/test/resources folder to read and write files as default.
In order to get access to it, use getAbsolutePath() method of File, or get() method of Paths combined with getAbsolutePath().
In order to access the resources folder under the target folder (which is the target folder of compiler under Maven), use getClassLoader() method of ClassLoader combined with getAbsolutePath().

EXAMPLE FOR GETTING TEST RESOURCES FOLDER:
import java.io.File;
..
String absolutePath = (new File("src" + File.separator + "test" + File.separator + "resources")).getAbsolutePath();

//or:

import java.nio.file.Paths;
..
String absolutePath = Paths.get("src","test","resources").toFile().getAbsolutePath();
END OF EXAMPLE

EXAMPLE FOR GETTING TARGET RESOURCES FOLDER:
import java.io.File;
...
String absolutePath = (new File(getClass().getClassLoader().getResource("example_resource.txt").getFile())).getAbsolutePath();
END OF EXAMPLE

=================================================================================
6. FAVORING COMPOSITION OVER INHERITANCE
=================================================================================
In OOP, inheritance is used to express that the subclass is a special class of the superclass, in other words presents relationship between the super and the sub.
Code re-usage means that a code can be a composite of previously created codes in case those codes can be used somewhere else as well.
Composition means that the code must show the meaning and purpose of the code. The right composition offers better understanding, better test-ability.
Based upon these three principles, inheritance should not be used for decreasing the amount of written code but not expressing the meaning of inheritance.
Also, inheritance should not decrease the readability and unity (the composition) of the code.
The right composition expresses the strategy itself while inheritance hides it.

EXAMPLE FOR WRONG USAGE OF CODE (INHERITANCE BUT NO COMPOSITION):
class AnnualData {
    private int year;
    private int total;
}
class MonthData extends AnnualData {
    private int month;
}
END OF EXAMPLE

In the above code the inheritance does not express that the MonthData is a special kind of AnnualData.
Also, the subclass is fragile, can harm encapsulation, any changes in the super class can break the subclass.
The correct solution following OOP principles would be the full composition of the second class, and no inheritance.
However, in case the complexity would grow over the edge, it can be good to out-sourcing the common code into a superclass (interface) like below.

EXAMPLE FOR RIGHT USAGE OF CODE (NO INHERITANCE BUT COMPOSITION):
class AnnualData {
    private int year;
    private int total;
}
class MonthData {
    private int year;
    private int month;
    private int total;
}
END OF EXAMPLE

EXAMPLE FOR RIGHT USAGE OF CODE (INHERITANCE AND COMPOSITION):
class StatData {
    private int total;
}
class AnnualData extends StatData {
    private int year;
}
class MonthData extends StatData {
    private int month;
}
END OF EXAMPLE

=================================================================================
7. PRINCIPLES OF SOFTWARE ENGINEERING
=================================================================================
Software engineering is a systematic and procedural approach to software development. It usually consists of collecting and documenting requirements from the users, designing and outlining the platform structure, coding or application development, user and developer testing, as well as after launch operations and maintenance support.
There are some basic principles governing good software engineering:
    - KISS
    - DRY (or DIE)
    - SOLID

The KISS (Keep It Simple, Stupid) principle: all software or application design and deployment should be done as simple as possible, with the least complexities and clear to understand development procedures. This principle ensures that the source code is made easy to debug (whenever required) and future maintenance by any other operations and maintenance software engineer becomes easier. Usually it is advised to keep only one method for one use case, in order to comply with the KISS principle.

The DRY or DIE (Don't Repeat Yourself or Duplication Is Evil) principle: every software engineer should aim to reduce repetition of information or methods within their work in order to avoid redundancy. Therefore, it's recommended to segregate the entire system of consideration into fragments. Dividing the code into smaller segments can help manage the code and use a single segment at any point, by calling, whenever required.

The SOLID principles:
    - S (Single responsibility) principle: every module should be designed to carry out just its responsibility over a single part of the functionality provided by the software
    - O (Open-closed) principle: any part of the software should be available and easily extended for further features, but should not be modified
    - L (Liskov substitution) principle: objects within a program can be replaced with instances of their sub-category types without changing the accuracy of that specific program
    - I (Interface segregation) principle: it is best to avoid adding new functionalities or methods to an existing interface. Rather it is recommended to incorporate a new interface and permit the classes to implement different interfaces based on the need
    - D (Dependency inversion) principle: we should always use a design pattern known as dependency inversion pattern, which is usually resolved by the use of dependency injection
Any software backend code that proceeds with the recommendations of the S.O.L.I.D. principles are much easier to be shared with collaborators, scaled up to meet volume, modified based on user requirements, tested for stress or usability, and managed and troubleshooted without any issues.

=================================================================================
8. QUALITY SOURCES OF JAVA, FRAMEWORKS AND FRONTEND
=================================================================================
https://www.baeldung.com
https://www.bezkoder.com
https://www.w3schools.com
https://blog.knoldus.com
https://html5boilerplate.com

=================================================================================
9. INCREASE ARRAY INDEX, JUMP TO FIRST ELEMENT WHEN REACHING LAST
=================================================================================
EXAMPLE FOR LOOP AND RESTARTING THE CYCLE IN AN ARRAY:
int index = 0;
int capacity = ...;

void push(int newValue) {
    array[index] = newValue;
    index = ++index % capacity; //increases until reaches capacity then it jumps back to 0
}
END OF EXAMPLE

=================================================================================
10. INCREASE ARRAY CAPACITY
=================================================================================
EXAMPLE FOR MODIFYING ARRAY CAPACITY:
int capacity = ...;
int[] array = new int[capacity];
int index = 0;

void push(int newValue) {
    array[index] = newValue;
    index++;
    //when reaches the limit, doubles the capacity
    if (index == array.length) {
        array = Arrays.copyOf(array, capacity * 2);
        capacity *= 2;
    }
}
END OF EXAMPLE

=================================================================================
11. INDEXOF WITH STREAM
=================================================================================
EXAMPLE FOR FINDING AN ELEMENT VIA STREAM:
class ClassName {
    private long id;
    //fields, constructors, getters
    public long getId() {
        return id;
    }
}
//for Lists:
List<ClassName> list = ...;
...
int indexOf(long id) {
	OptionalInt optionalInt = IntStream.range(0, list.size())
			.filter(n -> list.get(n).getId() == id)
			.findFirst();
	return optionalInt.isEmpty() ? -1 : optionalInt.getAsInt();
}
//for arrays:
ClassName[] array = ...;
...
int indexOf(long id) {
	OptionalInt optionalInt = IntStream.range(0, list.size())
			.filter(n -> array[n].getId() == id)
			.findFirst();
	return optionalInt.isEmpty() ? -1 : optionalInt.getAsInt();
}
END OF EXAMPLE

=================================================================================
12. RECURSIVE SORTING
=================================================================================

EXAMPLE FOR RECURSIVE SORTING:
int[] array = new int[10];
...
int indexLow = 0, indexHigh = 1;
int[] sortedArray = sort(array, indexLow, indexHigh);
...
public int[] sort(int[] array, int indexLow, int indexHigh) {
    if (indexLow == array.length - 1) {
        return array;
    }
    else {
        if (array[indexLow] > array[indexHigh]) {
            int temp = array[indexLow];
            array[indexLow] = array[indexHigh];
            array[indexHigh] = temp;
        } //if (array[indexLow] > array[indexHigh])
        if (indexHigh < array.length - 1) {
            indexHigh++;
        }
        else {
            indexLow++;
            indexHigh = indexLow + 1;
        }
        array = sort(array, indexLow, indexHigh);
    } //else: if (indexLow == array.length - 1)
}
END OF EXAMPLE

=================================================================================
13. LINKED LIST
=================================================================================
EXAMPLE FOR LINKED LIST:
public class Node {
	int value;
	Node next;
}

public void deleteNode(Node node, int value) {
	if (node == null) {
		throw new IllegalArgumentException("first argument is null");
	}

	Node actualNode = node;
	Node nextNode;
	while (actualNode != null) {
		nextNode = actualNode.next;
		while (nextNode != null && nextNode.value == value) {
			nextNode = nextNode.next;
		}
		actualNode.next = nextNode;
		actualNode = actualNode.next;
	}
}

public boolean loopDetection(Node node) {
	if (node == null) {
		throw new IllegalArgumentException("argument is null");
	}

	Node actualNode = node;
	Node detectorNode = actualNode.next;
	while (detectorNode != null && actualNode != detectorNode) {
		detectorNode = detectorNode.next;
		if (detectorNode != null && actualNode != detectorNode) {
			detectorNode = detectorNode.next;
			actualNode = actualNode.next;
		}
	}
	return actualNode == detectorNode;
}

public Node GetLastNode(Node node, int whichNodeFromLast) {
	if (node == null) {
		throw new IllegalArgumentException("first argument is null");
	}
	if (whichNodeFromLast < 0) {
		throw new IllegalArgumentException("second argument is negative");
	}

	Map<Integer, Node> nodes = new HashMap<>();
	int position = -1;
	Node actualNode = node;
	while (actualNode != null) {
		position++;
		nodes.put(position, actualNode);
		actualNode = actualNode.next;
	}

	if (whichNodeFromLast > position) {
		return null;
	}
	else {
		return nodes.get(position - whichNodeFromLast);
	}
}

public void removeDuplicates(Node node) {
	if (node == null) {
		throw new IllegalArgumentException("argument is null");
	}

	Set<Integer> foundValues = new HashSet<>();
	Node actualNode = node;
	foundValues.add(actualNode.value);
	Node nextNode = actualNode.next;

	while (actualNode != null) {
		while (nextNode != null && foundValues.contains(nextNode.value)) {
			nextNode = nextNode.next;
		}
		if (actualNode.next != nextNode) {
			actualNode.next = nextNode;
		}
		actualNode = nextNode;
		if (actualNode != null) {
			foundValues.add(actualNode.value);
			nextNode = actualNode.next;
		}
	}
}
END OF EXAMPLE

=================================================================================
14. DOUBLE LINKED LIST
=================================================================================
EXAMPLE FOR DOUBLE LINKED LIST:
public class Node {
	int value;
	Node previous;
	Node next;
}

public void deleteNode(Node node, int value) {
	if (node == null) {
		throw new IllegalArgumentException("first argument is null");
	}

	//backward from previous of given node
	Node actualNode = node.previous;
	while (actualNode != null) {
		if (actualNode.value == value) {
			if (actualNode.previous != null) {
				actualNode.previous.next = actualNode.next;
			}
			actualNode.next.previous = actualNode.previous;
		}
		actualNode = actualNode.previous;
	}

	//forward from given node
	actualNode = node;
	while (actualNode != null) {
		if (actualNode.value == value) {
			if (actualNode.next != null) {
				actualNode.next.previous = actualNode.previous;
			}
			if (actualNode.previous != null) {
				actualNode.previous.next = actualNode.next;
			}
		}
		actualNode = actualNode.next;
	}
}
END OF EXAMPLE

=================================================================================
15. QUEUE WITH ARRAY
=================================================================================
EXAMPLE FOR QUEUE:
public class MyQueue {

	private final int capacity;
	private final int[] queue;
	private int first;
	private int last;

	public MyQueue(int capacity) {
		if (capacity < 1) {
			throw new IllegalArgumentException("insufficient capacity");
		}
		this.capacity = capacity;
		this.queue = new int[capacity];
		first = -1;
		last = -1;
	}

	public void push(int newValue) throws Exception {
		int newLast = (last + 1) % capacity;
		if (newLast == first) {
			throw new Exception("full");
		}
		last = newLast;

		queue[last] = newValue;

		if (first == -1) {
			first++;
		}
	}

	public int pull() throws Exception {
		if (first == -1) {
			throw new Exception("empty");
		}

		int value = queue[first];

		if (first == last) {
			first = -1;
			last = -1;
		} else {
			first = (first + 1) % capacity;
		}
		return value;
	}
}
END OF EXAMPLE

=================================================================================
16. ROUND ROBIN QUEUE (WITH ARRAYLIST OF STRING ITERATORS)
=================================================================================
Round Robin structure:
    - the queue is made from series of collections or arrays forming a pool (here: ArrayList<Iterator<String>>)
    - the pool has an actual index which shows from which collection or array will be the next pulled element taken
    - push adds a new collection or array to the end of the pool
    - pull gets the first element (here: String) from the actual collection or array (here: Iteration<String>) in FIFO fashion, then jumps to the next collection or array

EXAMPLE FOR ROUND ROBIN QUEUE WITH ARRAYLIST OF STRING ITERATORS:
public class RoundRobinQueue {

	private final List<Iterator<String>> queue;
	private int lastPullIndex;

	public RoundRobinQueue() {
		this.queue = new ArrayList<>();
		lastPullIndex = -1;
	}

	public void push(List<String> items) {
		if (items == null) {
			throw new IllegalArgumentException("argument is null");
		}
		this.queue.add(items.iterator());
	}

	public String pull() {
/*
		Returns null when:
		- the queue is empty yet: no pushed List yet
		- the queue is already empty: all Strings were pulled (all Iterations have no next element)
		- the pulled element is null
		Returns empty String when the pulled element is an empty String.
		The next pull reads the next Iteration. If it was the actual last Iteration in the List and
			a new valid push arrives, the next pull will try the new Iteration.
*/

		if (queue.size() == 0) {
			return null;
		}

		int newPullIndex = (lastPullIndex + 1) % queue.size();
		while (!queue.get(newPullIndex).hasNext() && newPullIndex != lastPullIndex) {
			newPullIndex = (newPullIndex + 1) % queue.size();
		}

		if (queue.get(newPullIndex).hasNext()) {
			lastPullIndex = newPullIndex;
			return queue.get(lastPullIndex).next();
		}
		else {
			return null;
		}
	}
}
END OF EXAMPLE

=================================================================================
17. ROUND ROBIN QUEUE (WITH QUEUE OF STRING ITERATORS)
=================================================================================
Round Robin structure:
    - the queue is made from series of collections or arrays forming a pool (here: Queue<Iterator<String>>)
    - the pool (Queue) follows the FIFO model
    - push adds a new collection or array to the queue
    - pull gets the first element (here: Iteration) from the queue, process the next element in it (FIFO), then add it to the queue (it will be processed again after the original last element)

EXAMPLE FOR ROUND ROBIN QUEUE WITH QUEUE OF STRING ITERATORS:
public class RoundRobinQueueWithQueue {
	private final Queue<Iterator<String>> queue;

	public RoundRobinQueueWithQueue() {
		this.queue = new LinkedList<>();
	}

	public void push(List<String> strings) {
		if (strings == null || strings.size() == 0) {
			throw new IllegalArgumentException("invalid argument");
		}
		queue.offer(strings.iterator());
	}

	public String pull() {
		Iterator<String> iterator = queue.poll();

		//Queue is empty
		if (iterator == null) {
			return null;
		}

		String s = iterator.next();

		if (iterator.hasNext()) {
			queue.offer(iterator);
		}

		return s;
	}
}
END OF EXAMPLE

=================================================================================
18. PALINDROME (STRING EQUALS ITS REVERSED FORM)
=================================================================================
Palindrome:
    - the given string and its reversed form are identical (A, AA, ABA, ABBA, A A, A  A, A B A, AB BA)
    - spaces are usually used in checking

EXAMPLE FOR CHECKING PALINDROME:
public boolean isItPalindrom(String text) {
	//argument check
	if (text == null) {
		return false;
	}

	//clean all white spaces and non-visible characters
	//find it in other practice

	//palindrome check with StringBuilder and reversed loop
	StringBuilder sb = new StringBuilder();
	for (int i = text.length() - 1, limit = 0; i >= limit; i--) {
		sb.append(text.charAt(i));
	}
	return text.equals(sb.toString());

	//or:

	//palindrome check with StringBuilder.reverse()
	StringBuilder sb = new StringBuilder(text);
	return text.equals(sb.reverse().toString());

	//or:

	//palindrome check with single loop
	int i = 0;
	int length = text.length();
	while ((i < length / 2) &&
			text.charAt(i) == text.charAt(length - i - 1)) {
		++i;
	}
	return i == length / 2;
}
END OF EXAMPLE

=================================================================================
19. CLEAN ALL WHITE SPACES AND NON-VISIBLE CHARACTERS
=================================================================================
EXAMPLE FOR CLEANING SPACES AND NON-VISIBLES:
String s = ...;
s = s.replaceAll("\\s+",""); //as the number of consecutive spaces increases, performs better
s = s.replaceAll("\\s",""); //20% faster in normal circumstances
END OF EXAMPLE

MORE HERE: IntelliJ IDEA Beginner Tutorial | How to create Maven Project, https://www.youtube.com/watch?v=dxn5DsMWhGY
MORE HERE: https://www.jetbrains.com/help/idea/maven-support.html
MORE HERE: Working With Maven in IntelliJ IDEA, https://www.youtube.com/watch?v=pt3uB0sd5kY
MORE HERE: Maven Tutorial - Crash Course, https://www.youtube.com/watch?v=Xatr8AZLOsE
MORE HERE: https://programiz.pro/learn/master-java?utm_source=right-floating-block&utm_campaign=programiz&utm_medium=referral
MORE HERE: design patterns, https://www.tutorialspoint.com/design_pattern/design_pattern_overview.htm

=>MAVEN
=>AGILE DEVELOPMENT

